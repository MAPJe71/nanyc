#include <yuni/yuni.h>
#include "details/pass/build-ast-to-ir/scope.h"
#include "details/utils/check-for-valid-identifier-name.h"
#include "libnany-config.h"

using namespace Yuni;




namespace Nany
{
namespace IR
{
namespace Producer
{

	inline bool Scope::visitASTExprIdentifier(const Node& node, LVID& localvar)
	{
		// value fetching
		emitDebugpos(node);
		uint32_t rid = sequence().emitStackalloc(nextvar(), nyt_any);
		sequence().emitIdentify(rid, node.text, localvar);
		localvar = rid;

		return visitASTExprContinuation(node, localvar);
	}


	bool Scope::visitASTExprContinuation(const Node& node, LVID& localvar, bool allowScope)
	{
		bool success = true;
		for (auto& childptr: node.children)
		{
			auto& child = *childptr;
			switch (child.rule)
			{
				case rgIdentifier: success &= visitASTExprIdentifier(child, localvar); break;
				case rgExprValue:
				case rgExprGroup:  success &= visitASTExpr(child, localvar); break;
				case rgCall:       success &= visitASTExprCall(&child, localvar, &node); break;
				case rgExprSubDot: success &= visitASTExprSubDot(child, localvar); break;
				case rgNumber:     success &= visitASTExprNumber(child, localvar); break;
				case rgNew:        success &= visitASTExprNew(child, localvar); break;

				// typing - same as std expr
				case rgTypeSubDot: success &= visitASTExprSubDot(child, localvar); break;

				// strings
				case rgString:     success &= visitASTExprString(child, localvar); break;
				// when directly called from an expr, this rule is generated by the compiler itself
				case rgStringLiteral: success &= visitASTExprStringLiteral(child, localvar); break;

				// special stuff
				case rgTypeof:     success &= visitASTExprTypeof(child, localvar); break;
				case rgIntrinsic:  success &= visitASTExprIntrinsic(child, localvar); break;

				case rgIf:         success &= visitASTExprIfExpr(child, localvar); break;
				case rgWhile:      success &= visitASTExprWhile(child); break;

				case rgExprTemplate: success &= visitASTExprTemplate(child, localvar); break;

				// special for internal AST manipulation
				case rgRegister:   localvar = child.text.to<uint32_t>(); break;

				// scope may appear in expr (when expr are actually statements)
				case rgScope:  if (allowScope) {
					success &= visitASTExprScope(child);
					break;
				} // fallthru ok - if not then unexpected
				default:
					success = ICEUnexpectedNode(child, "[ir/expr/continuation]");
			}
		}
		return success;
	}


	bool Scope::visitASTExpr(const Node& orignode, LVID& localvar, bool allowScope)
	{
		assert(not orignode.children.empty());

		// reset the value of the localvar, result of the expr
		localvar = 0;

		auto& node = (orignode.rule == rgExpr
			and orignode.children.size() == 1 and orignode.children[0]->rule == rgExprValue)
			? *(orignode.children[0])
			: orignode;

		assert(node.rule == rgExpr or node.rule == rgExprValue or node.rule == rgExprGroup or node.rule == rgTypeDecl);
		assert(not node.children.empty());

		// always creating a new scope for a expr
		IR::Producer::Scope scope{*this};
		scope.emitDebugpos(node);
		bool r = scope.visitASTExprContinuation(node, localvar, allowScope);
		if (r and localvar != 0 and localvar != (uint32_t) -1)
		{
			scope.emitTmplParametersIfAny();
			scope.sequence().emitEnsureTypeResolved(localvar);
		}
		return r;
	}





} // namespace Producer
} // namespace IR
} // namespace Nany
