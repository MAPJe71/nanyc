#include <yuni/yuni.h>
#include <yuni/core/string.h>
#include <yuni/io/file.h>
#include <iostream>

using namespace Yuni;





static void craftClassInt(Clob& o, uint32_t bits, bool issigned, const AnyString& license, const AnyString& filename)
{
	o.clear();
	char c = (issigned) ? 'i' : 'u';
	ShortString16 suffix;
	suffix << c << bits;

	auto craftOperator = [&](auto callback) {
		callback(bits, c);
		if (issigned)
			callback(bits / 2, 'u');
		o << '\n';
	};


	o << license;
	o << "/// \\file    " << suffix << ".ny\n";
	o << "/// \\brief   Implementation of the class " << suffix << ", ";
	o << (issigned ? "Signed" : "Unsigned") << " integer with width of exactly " << bits << " bits\n";
	o << "/// \\ingroup std.core\n";
	o << "/// \\important THIS FILE IS AUTOMATICALLY GENERATED (see `nsl-core-generator.cpp`)\n";
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << "/// \\brief   " << (issigned ? "Signed" : "Unsigned");
	o << " integer with width of exactly " << bits << " bits\n";
	o << "/// \\ingroup std.core\n";
	o << "public class " << suffix << '\n';
	o << "{\n";
	o << "\toperator new;\n";
	craftOperator([&](uint32_t b, char targetsign)
	{
		for ( ; b >= 8; b /= 2)
			o << "\toperator new (self pod: __" << targetsign << b << ");\n";
	});

	o << '\n';
	o << "\toperator ++self: ref " << suffix << '\n';
	o << "\t{\n";
	o << "\t\tpod = !!nany_inc_" << suffix << "(pod);\n";
	o << "\t\treturn self;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator self++: ref " << suffix << '\n';
	o << "\t{\n";
	o << "\t\tvar tmp = self;\n";
	o << "\t\tpod = !!nany_inc_" << suffix << "(pod);\n";
	o << "\t\treturn tmp;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator --self: ref " << suffix << '\n';
	o << "\t{\n";
	o << "\t\tpod = !!nany_dec_" << suffix << "(pod);\n";
	o << "\t\treturn self;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator self--: ref " << suffix << '\n';
	o << "\t{\n";
	o << "\t\tvar tmp = self;\n";
	o << "\t\tpod = !!nany_dec_" << suffix << "(pod);\n";
	o << "\t\treturn tmp;\n";
	o << "\t}\n";
	o << '\n';
	o << '\n';


	auto craftMemberOperator = [&](const AnyString& op, const AnyString& intrinsic)
	{
		craftOperator([&](uint32_t b, char targetsign)
		{
			for ( ; b >= 8; b /= 2)
			{
				o << "\toperator " << op << " (cref x: " << targetsign << b << "): ref " << suffix << '\n';
				o << "\t{\n";
				o << "\t\tpod = !!" << intrinsic << suffix << '_' << targetsign << b << "(pod, x.pod);\n";
				o << "\t\treturn self;\n";
				o << "\t}\n\n";

				o << "\toperator " << op << " (cref x: __" << targetsign << b << "): ref " << suffix << '\n';
				o << "\t{\n";
				o << "\t\tpod = !!" << intrinsic << suffix << '_' << targetsign << b << "(pod, x);\n";
				o << "\t\treturn self;\n";
				o << "\t}\n\n";
			}
		});
	};

	craftMemberOperator("+=", "nany_add_");
	craftMemberOperator("-=", "nany_sub_");
	craftMemberOperator("*=", "nany_mult_");
	craftMemberOperator("/=", "nany_div_");

	o << "\t//! The real integer representation\n";
	o << "\tvar pod: __" << suffix << " = 0" << suffix << ";\n";
	o << "}\n";
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';

	auto craftGlobalBoolOperator = [&](const AnyString& op, const AnyString& intrinsic)
	{
		craftOperator([&](uint32_t b, char targetsign)
		{
			for ( ; b >= 8; b /= 2)
			{
				o << "public operator ";
				o << op << " (a: __" << suffix << ", b: __" << targetsign << b << "): ref bool\n";
				o << "\t-> !!" << intrinsic << suffix << "__" << targetsign << b << "(a, b);\n\n";

				o << "public operator ";
				o << op << " (cref a: " << suffix << ", cref b: " << targetsign << b << "): ref bool\n";
				o << "\t-> a.pod " << op << " b.pod;\n\n";

				o << "public operator ";
				o << op << " (cref a: " << suffix << ", cref b: __" << targetsign << b << "): ref bool\n";
				o << "\t-> a.pod " << op << " b;\n\n";

				o << "public operator ";
				o << op << " (cref a: __" << suffix << ", cref b: " << targetsign << b << "): ref bool\n";
				o << "\t-> a " << op << " b.pod;\n\n";

				o << '\n';
			}
			o << '\n';
		});
	};

	craftGlobalBoolOperator("==", "nany_is_equal_");
	craftGlobalBoolOperator("!=", "nany_is_not_equal_");
	craftGlobalBoolOperator("<",  "nany_is_less_");
	craftGlobalBoolOperator("<=", "nany_is_less_or_equal_");
	craftGlobalBoolOperator(">",  "nany_is_greater_");
	craftGlobalBoolOperator(">=", "nany_is_greater_or_equal_");



	auto craftGlobalOperator = [&](const AnyString& op)
	{
		o << "public operator ";
		o << op << " (cref a: " << suffix << ", cref b): ref " << suffix << '\n';
		o << "\t-> (new a) " << op << "= b;\n\n";

		craftOperator([&](uint32_t b, char targetsign)
		{
			for ( ; b >= 8; b /= 2)
			{
				o << "public operator ";
				o << op << " (cref a: __" << targetsign << b << ", cref b: " << suffix << "): ref " << suffix << '\n';
				o << "\t-> (new " << suffix << "(a)) " << op << "= b;\n\n";
			}
			o << '\n';
		});
	};

	craftGlobalOperator("+");
	craftGlobalOperator("-");
	craftGlobalOperator("*");
	craftGlobalOperator("/");


	o.trimRight();
	IO::File::SetContent(filename, o);
}





int main(int argc, char** argv)
{
	if (argc != 3)
	{
		std::cerr << "usage: <license-header-file> <folder>\n";
		return 1;
	}

	String license;
	if (IO::errNone != IO::File::LoadFromFile(license, argv[1]))
	{
		std::cerr << "failed to load header file from '" << argv[1] << "'\n";
		return 1;
	}

	AnyString folder = argv[2];

	Clob out;
	out.reserve(1024 * 32);
	String filename;
	filename.reserve(1024);

	for (uint32_t bits = 64; bits >= 8; bits /= 2)
	{
		filename.clear() << folder << "/u" << bits << ".ny";
		craftClassInt(out, bits, false, license, filename);
		filename.clear() << folder << "/i" << bits << ".ny";
		craftClassInt(out, bits, true,  license, filename);
	}
	return 0;
}
